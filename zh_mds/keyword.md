

[Elastic Docs](/guide/) ›[Elasticsearch Guide [8.9]](index.md)
›[Mapping](mapping.md) ›[Field data types](mapping-types.md)

[« Join field type](parent-join.md) [Nested field type »](nested.md)

## 关键字类型系列

关键字系列包括以下字段类型：

* "关键字"，用于结构化内容，例如 ID、电子邮件地址、主机名、状态代码、邮政编码或标签。  * "constant_keyword"表示始终包含相同值的关键字字段。  * "通配符"表示非结构化机器生成的内容。"通配符"类型针对具有大值或高基数的字段进行了优化。

关键字字段通常用于排序、聚合和术语级查询，例如"term"。

避免使用关键字字段进行全文搜索。请改用"文本"字段类型。

### 关键字字段类型

下面是基本"关键字"字段的映射示例：

    
    
    response = client.indices.create(
      index: 'my-index-000001',
      body: {
        mappings: {
          properties: {
            tags: {
              type: 'keyword'
            }
          }
        }
      }
    )
    puts response
    
    
    res, err := es.Indices.Create(
    	"my-index-000001",
    	es.Indices.Create.WithBody(strings.NewReader(`{
    	  "mappings": {
    	    "properties": {
    	      "tags": {
    	        "type": "keyword"
    	      }
    	    }
    	  }
    	}`)),
    )
    fmt.Println(res, err)
    
    
    PUT my-index-000001
    {
      "mappings": {
        "properties": {
          "tags": {
            "type":  "keyword"
          }
        }
      }
    }

### 映射数字标识符

并非所有数值数据都应映射为数值字段数据类型。Elasticsearch 为"range"查询优化数值字段，例如"整数"或"long"。但是，"关键字"字段更适合"术语"和其他术语级查询。

标识符(如 ISBN 或产品 ID)很少在"范围"查询中使用。但是，它们通常使用术语级查询进行检索。

在以下情况下，请考虑将数字标识符映射为"关键字"：

* 您不打算使用"范围"查询搜索标识符数据。  * 快速检索很重要。对"关键字"字段的"术语"查询搜索通常比对数值字段的"术语"搜索更快。

如果不确定要使用哪个，可以使用多字段将数据映射为"关键字"_和_数字数据类型。

#### 基本关键字字段的参数

"关键字"字段接受以下参数：

"doc_values"

     Should the field be stored on disk in a column-stride fashion, so that it can later be used for sorting, aggregations, or scripting? Accepts `true` (default) or `false`. 
[`eager_global_ordinals`](eager-global-ordinals.html "eager_global_ordinals")

     Should global ordinals be loaded eagerly on refresh? Accepts `true` or `false` (default). Enabling this is a good idea on fields that are frequently used for terms aggregations. 
[`fields`](multi-fields.html "fields")

     Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one field for search and a multi-field for sorting and aggregations. 
[`ignore_above`](ignore-above.html "ignore_above")

     Do not index any string longer than this value. Defaults to `2147483647` so that all values would be accepted. Please however note that default dynamic mapping rules create a sub `keyword` field that overrides this default by setting `ignore_above: 256`. 
[`index`](mapping-index.html "index")

     Should the field be quickly searchable? Accepts `true` (default) and `false`. `keyword` fields that only have [`doc_values`](doc-values.html "doc_values") enabled can still be queried, albeit slower. 
[`index_options`](index-options.html "index_options")

     What information should be stored in the index, for scoring purposes. Defaults to `docs` but can also be set to `freqs` to take term frequency into account when computing scores. 
[`meta`](mapping-field-meta.html "meta")

     Metadata about the field. 
[`norms`](norms.html "norms")

     Whether field-length should be taken into account when scoring queries. Accepts `true` or `false` (default). 
[`null_value`](null-value.html "null_value")

     Accepts a string value which is substituted for any explicit `null` values. Defaults to `null`, which means the field is treated as missing. Note that this cannot be set if the `script` value is used. 
`on_script_error`

     Defines what to do if the script defined by the `script` parameter throws an error at indexing time. Accepts `fail` (default), which will cause the entire document to be rejected, and `continue`, which will register the field in the document's [`_ignored`](mapping-ignored-field.html "_ignored field") metadata field and continue indexing. This parameter can only be set if the `script` field is also set. 
`script`

     If this parameter is set, then the field will index values generated by this script, rather than reading the values directly from the source. If a value is set for this field on the input document, then the document will be rejected with an error. Scripts are in the same format as their [runtime equivalent](runtime-mapping-fields.html "Map a runtime field"). Values emitted by the script are normalized as usual, and will be ignored if they are longer that the value set on `ignore_above`. 
[`store`](mapping-store.html "store")

     Whether the field value should be stored and retrievable separately from the [`_source`](mapping-source-field.html "_source field") field. Accepts `true` or `false` (default). 
[`similarity`](similarity.html "similarity")

     Which scoring algorithm or _similarity_ should be used. Defaults to `BM25`. 
[`normalizer`](normalizer.html "normalizer")

     How to pre-process the keyword prior to indexing. Defaults to `null`, meaning the keyword is kept as-is. 
`split_queries_on_whitespace`

     Whether [full text queries](full-text-queries.html "Full text queries") should split the input on whitespace when building a query for this field. Accepts `true` or `false` (default). 
`time_series_dimension`

    

(可选，布尔值)

将字段标记为时序维度。默认为"假"。

"index.mapping.dimension_fields.limit"索引设置可限制索引中的维度数。

维度字段具有以下约束：

* "doc_values"和"索引"映射参数必须为"true"。  * 字段值不能是数组或多值。  * 字段值不能大于 1024 字节。  * 该字段不能使用"规范化器"。

### 合成的"_source"

合成"_source"仅对 TSDB 索引(将"index.mode"设置为"time_series"的索引)正式发布。对于其他指数，合成"_source"处于技术预览状态。技术预览版中的功能可能会在将来的版本中更改或删除。Elastic 将尽最大努力修复任何问题，但技术预览版中的功能不受官方 GA 功能的 SLA 支持的约束。

"关键字"字段在其默认配置中支持合成"_source"。合成"_source"不能与"规范化器"或"copy_to"一起使用。

默认情况下，合成源对"关键字"字段进行排序并删除重复项。例如：

    
    
    response = client.indices.create(
      index: 'idx',
      body: {
        mappings: {
          _source: {
            mode: 'synthetic'
          },
          properties: {
            kwd: {
              type: 'keyword'
            }
          }
        }
      }
    )
    puts response
    
    response = client.index(
      index: 'idx',
      id: 1,
      body: {
        kwd: [
          'foo',
          'foo',
          'bar',
          'baz'
        ]
      }
    )
    puts response
    
    
    PUT idx
    {
      "mappings": {
        "_source": { "mode": "synthetic" },
        "properties": {
          "kwd": { "type": "keyword" }
        }
      }
    }
    PUT idx/_doc/1
    {
      "kwd": ["foo", "foo", "bar", "baz"]
    }

将成为：

    
    
    {
      "kwd": ["bar", "baz", "foo"]
    }

如果"关键字"字段将"store"设置为"true"，则保留顺序和重复项。例如：

    
    
    response = client.indices.create(
      index: 'idx',
      body: {
        mappings: {
          _source: {
            mode: 'synthetic'
          },
          properties: {
            kwd: {
              type: 'keyword',
              store: true
            }
          }
        }
      }
    )
    puts response
    
    response = client.index(
      index: 'idx',
      id: 1,
      body: {
        kwd: [
          'foo',
          'foo',
          'bar',
          'baz'
        ]
      }
    )
    puts response
    
    
    PUT idx
    {
      "mappings": {
        "_source": { "mode": "synthetic" },
        "properties": {
          "kwd": { "type": "keyword", "store": true }
        }
      }
    }
    PUT idx/_doc/1
    {
      "kwd": ["foo", "foo", "bar", "baz"]
    }

将成为：

    
    
    {
      "kwd": ["foo", "foo", "bar", "baz"]
    }

长于"ignore_above"的值将被保留，但排序到末尾。例如：

    
    
    response = client.indices.create(
      index: 'idx',
      body: {
        mappings: {
          _source: {
            mode: 'synthetic'
          },
          properties: {
            kwd: {
              type: 'keyword',
              ignore_above: 3
            }
          }
        }
      }
    )
    puts response
    
    response = client.index(
      index: 'idx',
      id: 1,
      body: {
        kwd: [
          'foo',
          'foo',
          'bang',
          'bar',
          'baz'
        ]
      }
    )
    puts response
    
    
    PUT idx
    {
      "mappings": {
        "_source": { "mode": "synthetic" },
        "properties": {
          "kwd": { "type": "keyword", "ignore_above": 3 }
        }
      }
    }
    PUT idx/_doc/1
    {
      "kwd": ["foo", "foo", "bang", "bar", "baz"]
    }

将成为：

    
    
    {
      "kwd": ["bar", "baz", "foo", "bang"]
    }

### 常量关键字字段类型

常量关键字是"关键字"字段的专用化，适用于索引中的所有文档都具有相同值的情况。

    
    
    response = client.indices.create(
      index: 'logs-debug',
      body: {
        mappings: {
          properties: {
            "@timestamp": {
              type: 'date'
            },
            message: {
              type: 'text'
            },
            level: {
              type: 'constant_keyword',
              value: 'debug'
            }
          }
        }
      }
    )
    puts response
    
    
    PUT logs-debug
    {
      "mappings": {
        "properties": {
          "@timestamp": {
            "type": "date"
          },
          "message": {
            "type": "text"
          },
          "level": {
            "type": "constant_keyword",
            "value": "debug"
          }
        }
      }
    }

"constant_keyword"支持与"关键字"字段相同的查询和聚合，但利用所有文档每个索引具有相同值的事实来更有效地执行查询。

既允许提交没有字段值的文档，也可以提交值等于映射中配置的值的文档。以下两个索引请求是等效的：

    
    
    POST logs-debug/_doc
    {
      "date": "2019-12-12",
      "message": "Starting up Elasticsearch",
      "level": "debug"
    }
    
    POST logs-debug/_doc
    {
      "date": "2019-12-12",
      "message": "Starting up Elasticsearch"
    }

但是，不允许提供与映射中配置的值不同的值。

如果映射中未提供"值"，则该字段将根据第一个索引文档中包含的值自动配置自身。虽然此行为可能很方便，但请注意，这意味着如果单个有害文档的值错误，则可能导致所有其他文档被拒绝。

在提供值(通过映射或从文档)之前，对该字段的查询将不匹配任何文档。这包括"存在"查询。

字段的"值"在设置后无法更改。

#### 常量关键字字段的参数

接受以下映射参数：

"元"

|

有关字段的元数据。   ---|---"价值"

|

要与索引中的所有文档关联的值。如果未提供此参数，则根据编制索引的第一个文档设置此参数。   ### 通配符字段类型编辑

"通配符"字段类型是一个专门的关键字字段，用于您计划使用类似 grep 的"通配符"和"正则表达式"查询搜索的非结构化机器生成的内容。"通配符"类型针对具有大值或高基数的字段进行了优化。

**映射非结构化内容**

您可以将包含非结构化内容的字段映射到"文本"或关键字系列字段。最佳字段类型取决于内容的性质以及您计划如何搜索字段。

在以下情况下使用"文本"字段类型：

* 内容是人类可读的，例如电子邮件正文或产品描述。  * 您计划使用全文查询在字段中搜索单个单词或短语，例如"棕色狐狸跳了"。Elasticsearch 分析"文本"字段以返回与这些查询最相关的结果。

在以下情况下使用关键字族字段类型：

* 内容是机器生成的，例如日志消息或HTTP请求信息。  * 您计划使用术语级查询在字段中搜索精确的完整值(如"org.foo.bar")或部分字符序列(如"org.foo.*")。

**选择关键字系列字段类型**

如果选择关键字系列字段类型，则可以根据字段值的基数和大小将该字段映射为"关键字"或"通配符"字段。如果您计划使用"通配符"或"正则表达式"查询定期搜索字段并满足以下条件之一，请使用"通配符"类型：

* 该字段包含超过一百万个唯一值。 和 您计划使用带有前导通配符的模式(如"*foo"或"*baz")定期搜索字段。

* 该字段包含大于 32KB 的值。 和 您计划使用任何通配符模式定期搜索字段。

否则，请使用"关键字"字段类型，以加快搜索速度、编制索引速度并降低存储成本。有关深入的比较和决策流程图，请参阅我们的相关博客文章。

**从"文本"字段切换到关键字字段**

如果您之前使用"文本"字段为机器生成的非结构化内容编制索引，则可以重新编制索引以将映射更新为"关键字"或"通配符"字段。我们还建议您更新应用程序或工作流，以将字段上任何基于单词的全文查询替换为等效的术语级查询。

在内部，"通配符"字段使用 ngram 索引整个字段值并存储完整的字符串。索引用作粗略筛选器，以减少然后通过检索和检查完整值来检查的值的数量。此字段特别适合在日志行上运行类似 grep 的查询。存储成本通常低于"关键字"字段，但完整字词的完全匹配项的搜索速度较慢。如果字段值共享许多前缀(例如同一网站的 URL)，则"通配符"字段的存储成本可能高于等效的"关键字"字段。

按如下方式索引和搜索通配符字段

    
    
    response = client.indices.create(
      index: 'my-index-000001',
      body: {
        mappings: {
          properties: {
            my_wildcard: {
              type: 'wildcard'
            }
          }
        }
      }
    )
    puts response
    
    response = client.index(
      index: 'my-index-000001',
      id: 1,
      body: {
        my_wildcard: 'This string can be quite lengthy'
      }
    )
    puts response
    
    response = client.search(
      index: 'my-index-000001',
      body: {
        query: {
          wildcard: {
            my_wildcard: {
              value: '*quite*lengthy'
            }
          }
        }
      }
    )
    puts response
    
    
    PUT my-index-000001
    {
      "mappings": {
        "properties": {
          "my_wildcard": {
            "type": "wildcard"
          }
        }
      }
    }
    
    PUT my-index-000001/_doc/1
    {
      "my_wildcard" : "This string can be quite lengthy"
    }
    
    GET my-index-000001/_search
    {
      "query": {
        "wildcard": {
          "my_wildcard": {
            "value": "*quite*lengthy"
          }
        }
      }
    }

#### 通配符字段的参数

"通配符"字段接受以下参数：

"null_value"

|

接受替换任何显式"null"值的字符串值。默认为"null"，表示该字段被视为缺失。   ---|--- "ignore_above"

|

不要索引任何长度超过此值的字符串。默认为"2147483647"，以便接受所有值。   ####Limitationsedit

* "通配符"字段与关键字字段一样未标记化，因此不支持依赖于单词位置的查询，例如短语查询。  * 运行"通配符"查询时，将忽略任何"重写"参数。评分始终是一个恒定的分数。

### 合成的"_source"

"通配符"字段支持合成的"_source"，只要它们不声明"copy_to"。

合成源始终对"通配符"字段进行排序。例如：

    
    
    response = client.indices.create(
      index: 'idx',
      body: {
        mappings: {
          _source: {
            mode: 'synthetic'
          },
          properties: {
            card: {
              type: 'wildcard'
            }
          }
        }
      }
    )
    puts response
    
    response = client.index(
      index: 'idx',
      id: 1,
      body: {
        card: [
          'king',
          'ace',
          'ace',
          'jack'
        ]
      }
    )
    puts response
    
    
    PUT idx
    {
      "mappings": {
        "_source": { "mode": "synthetic" },
        "properties": {
          "card": { "type": "wildcard" }
        }
      }
    }
    PUT idx/_doc/1
    {
      "card": ["king", "ace", "ace", "jack"]
    }

将成为：

    
    
    {
      "card": ["ace", "jack", "king"]
    }

[« Join field type](parent-join.md) [Nested field type »](nested.md)
