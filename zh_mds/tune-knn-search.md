

[Elastic Docs](/guide/) ›[Elasticsearch Guide [8.9]](index.md) ›[How
to](how-to.md)

[« Tune for search speed](tune-for-search-speed.md) [Tune for disk usage
»](tune-for-disk-usage.md)

## 调整近似 kNN搜索

Elasticsearch 支持近似 k 最近邻搜索，以便有效地查找查询向量的_k_nearest向量。由于近似 kNN 搜索的工作方式与其他查询不同，因此对其性能有特殊的考虑。

其中许多建议有助于提高搜索速度。利用近似kNN的索引算法在后台运行搜索以创建向量索引结构。因此，这些相同的建议也有助于索引速度。

### 更喜欢"dot_product"而不是"余弦"

在为近似 kNN 搜索索引向量时，您需要指定用于比较向量的"相似性"函数。如果您想通过余弦相似性比较向量，有两种选择。

"余弦"选项接受任何浮点向量并计算余弦相似性。虽然这对于测试很方便，但它并不是最有效的方法。相反，我们建议使用"dot_product"选项来计算相似性。要使用"dot_product"，需要提前对所有向量进行归一化以使其长度为 1。"dot_product"选项明显更快，因为it避免在搜索过程中执行额外的矢量长度计算。

### 确保数据节点有足够的内存

Elasticsearch使用HNSW算法进行近似kNN搜索。HNSW是一种基于图形的算法，仅当大多数矢量数据保存在内存中时，它才能有效地工作。您应该确保数据节点至少有足够的 RAM 来保存矢量数据和索引结构。要检查矢量数据的大小，您可以使用 Analyzeindex 磁盘使用情况 API.As 松散的经验法则，假设默认的 HNSW 选项，使用的字节将为"num_vectors * 4 * (num_dimensions + 12)"。使用"字节"element_type时，所需的空间将更接近"num_vectors * (num_dimensions + 12)"。请注意，所需的 RAM 用于文件系统缓存，它与 Javaheap 是分开的。

数据节点还应为需要 RAM 的其他方式留出缓冲区。例如，索引可能还包括文本字段和数字，这也受益于使用文件系统缓存。建议使用特定数据集运行基准测试，以确保有足够的内存量来提供良好的搜索性能。您可以在此处和此处找到我们用于夜间基准测试的一些数据集和配置示例。

### 预热文件系统缓存

如果运行 Elasticsearch 的计算机重新启动，文件系统缓存将为空，因此操作系统需要一些时间才能将索引的热区域加载到内存中，以便快速执行搜索操作。您可以使用"index.store.preload"设置根据文件扩展名显式告诉操作系统哪些文件应该加载到内存中。

如果文件系统缓存不够大，无法容纳所有数据，则在太多索引或太多文件上急切地将数据加载到文件系统缓存中将使搜索_变慢_。请谨慎使用。

以下文件扩展名用于近似 kNN 搜索："vec"(用于矢量值)、"vex"(用于 HNSW 图)、"vem"(用于元数据)。

### 减小矢量维数

kNN搜索的速度与向量维数呈线性关系，因为每个相似性计算都考虑了两个向量中的每个元素。只要有可能，最好使用较低维度的向量。一些嵌入模型有不同的"尺寸"，有低维和高维选项可用。您还可以尝试使用降维技术，如 PCA。在尝试不同的方法时，重要的是要衡量对相关性的影响，以确保搜索质量仍然可以接受。

### 从"_source"中排除向量场

Elasticsearch 将索引时传递的原始 JSON 文档存储在"_source"字段中。默认情况下，搜索结果中的每个命中都包含完整的文档"_source"。当文档包含高维"dense_vector"字段时，"_source"可能非常大且加载成本很高。这可能会大大减慢kNN搜索的速度。

您可以通过"排除"映射参数禁用在"_source"中存储"dense_vector"字段。这可以防止在搜索过程中加载和返回大型向量，并且还减少了索引大小。从"_source"中省略的向量仍然可以在kNN搜索中使用，因为它依赖于单独的数据结构来执行搜索。在使用"排除"参数之前，请确保查看从"_source"省略字段的缺点。

### 减少索引段的数量

Elasticsearch 分片由段组成，段是索引中的内部存储元素。对于近似的kNN搜索，Elasticsearch将每个段的密集向量值存储为HNSW图。kNN搜索必须检查每个段，搜索一个又一个HNSW图。这意味着如果段较少，kNNsearch可以明显更快。默认情况下，Elasticsearch 会定期通过后台合并过程将较小的段合并为较大的段。如果这还不够，您可以采取明确的步骤来减少索引段的数量。

#### 强制合并到一个分段

强制合并操作强制索引合并。如果强制合并到一个段，则 kNN 搜索只需检查单个全包 HNSW 图。强制合并"dense_vector"字段是一项成本高昂的操作，可能需要大量时间才能完成。

**我们建议仅强制合并只读索引(意味着索引不再接收写入)。** 更新或删除文档时，旧版本不会立即删除，而是软删除并标有"逻辑删除"。这些软删除的文档会在常规段合并期间自动清理。但是强制合并可能会导致产生非常大(> 5GB)的段，这些段不符合常规合并的条件。因此，软删除文档的数量可能会快速增长，从而导致磁盘使用率更高，搜索性能更差。如果定期强制合并索引接收写入，这也会使快照更加昂贵，因为新文档无法增量备份。

#### 在批量索引期间创建大型细分

一种常见的模式是首先执行初始批量上传，然后使索引可用于搜索。您可以调整索引设置以鼓励 Elasticsearch 创建更大的初始段，而不是强制合并：

* 确保在批量上传期间没有搜索，并通过将其设置为"-1"来禁用"index.refresh_interval"。这可以防止刷新操作并避免创建额外的段。  * 给 Elasticsearch 一个大的索引缓冲区，这样它就可以在刷新之前接受更多的文档。默认情况下，"indices.memory.index_buffer_size"设置为堆大小的 10%。对于像 32GB 这样的大量堆大小，这通常就足够了。要允许使用完整的索引缓冲区，您还应该增加限制"index.translog.flush_threshold_size"。

### 避免在搜索过程中使用繁重的索引

主动索引文档可能会对近似的 kNNsearch 性能产生负面影响，因为索引线程会从搜索中窃取计算资源。当同时进行索引和搜索时，Elasticsearch 也会频繁刷新，这会创建几个小段。这也损害了搜索性能，因为当有更多的段时，近似的kNN搜索速度较慢。

如果可能，最好避免在近似 kNN搜索期间进行大量索引。如果需要重新索引所有数据(可能是因为向量嵌入模型已更改)，则最好将新文档重新索引到单独的索引中，而不是就地更新它们。这有助于避免上述速度减慢，并防止由于频繁的文档更新而导致昂贵的合并操作。

### 通过在 Linux 上使用适度的预读值来避免页面缓存抖动

搜索可能会导致大量随机读取 I/O。当底层块设备具有较高的预读值时，可能会有很多不必要的读取 I/Odone，尤其是在使用内存映射访问文件时(请参阅存储类型)。

大多数Linux发行版对单个普通设备使用合理的预读值"128KiB"，但是，当使用软件raid，LVM或dm-crypt时，生成的块设备(支持Elasticsearch path.data)最终可能会具有非常大的预读值(在几个MiB的范围内)。这通常会导致严重的页面(文件系统)缓存抖动，从而对搜索(或更新)性能产生负面影响。

您可以使用"lsblk -oNAME，RA，MOUNTPOINT，TYPE，SIZE"检查"KiB"中的当前值。请参阅发行版的文档，了解如何更改此值(例如，使用"udev"规则来持久化交叉重启，或通过 blockdev --setra 作为瞬态设置)。我们建议预读的值为"128KiB"。

"blockdev"期望值在512字节扇区中，而"lsblk"报告"KiB"中的值。例如，要暂时将预读设置为"128KiB"，for'/dev/nvme0n1'，请指定"blockdev --setra 256 /dev/nvme0n1"。

[« Tune for search speed](tune-for-search-speed.md) [Tune for disk usage
»](tune-for-disk-usage.md)
